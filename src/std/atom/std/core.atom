module std.core;

pub extern fn println(values);
pub extern fn some(value);

pub extern fn rt_raise(exception);

pub class Int {
    pub extern fn size();
    pub fn toString() -> f"{this}";
    pub static fn typeId() -> 1;
}

pub class Float {
    pub extern fn floor();
    pub fn toString() -> f"{this}";
    pub static fn typeId() -> 2;
}

pub class Char {
    pub fn toString() -> f"{this}";
    pub static fn typeId() -> 3;
}

pub class Byte {
    pub fn toString() -> f"{this}";
    pub static fn typeId() -> 4;
}

pub class Bool {
    pub fn toString() -> f"{this}";
    pub static fn typeId() -> 5;
}

pub class Symbol {
    pub fn toString() -> f"{this}".substr(1);
    pub static fn typeId() -> 6;
}

pub class Ref {
    pub static fn typeId() -> 7;
}

pub class Fn {
    pub extern fn name();
    pub static fn typeId() -> 8;
}

pub class Tuple {
    pub static fn typeId() -> 9;
}

pub class Class {
    pub static fn typeId() -> 10;
}

pub class Interface {
    pub static fn typeId() -> 11;
}

pub class Closure {
    pub static fn typeId() -> 12;
}

pub class Method {
    pub static fn typeId() -> 13;
}

pub class String {
    pub let length;

    pub extern fn upper();
    pub extern fn lower();
    pub extern fn split(pattern);
    pub extern fn startsWith(pattern);
    pub extern fn endsWith(pattern);
    pub extern fn contains(pattern);
    pub extern fn count(pattern);
    pub extern fn find(pattern);
    pub extern fn substr(index);
    pub extern fn replace(pattern, replacement);
    pub extern fn chars();
    pub extern fn bytes();
    pub extern fn repeat(n);
    pub extern fn trim();
    pub extern fn len();
    pub static fn typeId() -> 14;

    pub fn toString() {
        return this;
    }

    pub fn containsAny(values) {
        let chars = this.chars();

        for c2 in values.chars() {
            for c1 in chars {
                if c1 == c2 {
                    return true;
                }
            }
        }

        return false;
    }
}

pub class Object {
    pub static fn typeId() -> 15;
}

pub class Array extends GetIterator {
    pub extern fn remove(index);
    pub extern fn push(value);
    pub extern fn pop();
    pub extern fn len();
    pub extern fn clear();
    pub static fn typeId() -> 16;
    
    pub fn iter() -> ArrayIterator.new(this);
    pub fn isEmpty() -> this.len() == 0;

    pub fn append(other) {
        for {
            let item = other.remove(0);

            if !item.isSome() {
                break;
            }

            this.push(item!);
        }
    }

    pub fn contains(value) {
        for item in this {
            if item == value {
                return true;
            }
        }

        return false;
    }

    pub fn join(separator) {
        let mut output = "";
        let length = this.len();

        for i in 0..length {
            let value = this[i];

            if value is String {
                output.append(value);
            } else {
                output.append(f"{value}");
            }

            if i < length - 1 {
                output.append(separator);
            }
        }

        return output;
    }
}

pub class Option {
    pub extern fn isSome();
    pub extern fn isNone();
    pub static fn typeId() -> 17;

    pub fn unwrapOr(alt) {
        if this.isSome() {
            return this!;
        }

        return alt;
    }
}

pub class RustObject {
    pub static fn typeId() -> 18;
}

pub class RangeStep extends GetIterator {
    let range;
    let step;

    pub static fn new(range, step) -> RangeIterator(range: range, step: step);
    pub fn iter() -> RangeIterator.new(this.range.start, this.range.end, this.step);
}

pub class Range extends GetIterator {
    pub let start;
    pub let end;

    pub fn iter() -> RangeIterator.new(this.start, this.end, 1);
    pub fn step(n) -> RangeStep.new(this, n);
}

pub class RangeIterator {
    let start;
    let end;
    let step;
    let mut index;

    pub static fn new(start, end, step) -> RangeIterator(start: start, end: end, step: step, index: 0);

    pub fn next() {
        let index = this.start + this.index;

        if index >= this.end {
            return nil;
        }

        let value = some(index);

        this.index += this.step;

        return value;
    }
}

pub interface Iterable {
    fn iter();
}

pub mixin GetIterator {
    pub fn enum() -> Enum(iterator: this.iter());

    pub fn collect() {
        let mut output = [];

        for item in this {
            output.push(item);
        }

        return output;
    }

    pub fn nth(index) {
        let iter = this.iter();

        for i in 0..index {
            if iter.next().isNone() {
                return nil;
            }
        }

        return iter.next();
    }

    pub fn first() -> this.nth(0);

    pub fn last() {
        let mut last = nil;

        for item in this {
            last = some(item);
        }

        return last;
    }

    pub fn filter(filter) -> Filter(iterator: this.iter(), filterFn: filter);
}

pub class FilterIterator {
    let iterator;
    let filterFn;

    pub fn next() {
        for {
            let item = this.iterator.next();

            if item.isNone() {
                return nil;
            }

            if this.filterFn(item!) {
                return item;
            }
        }
    }
}

pub class Filter extends GetIterator {
    let iterator;
    let filterFn;

    pub fn iter() -> FilterIterator(iterator: this.iterator, filterFn: this.filterFn);
}

pub class EnumIter {
    let iterator;
    let mut index;

    pub fn next() {
        let index = this.index;
        let item = this.iterator.next();

        if item.isNone() {
            return nil;
        }

        this.index += 1;

        return some((index, item!));
    }
}

pub class Enum extends GetIterator {
    let iterator;

    pub fn iter() -> EnumIter(iterator: this.iterator, index: 0);
}

pub class ArrayIterator {
    let array;
    let mut index;

    pub static fn new(array) -> ArrayIterator(array: array, index: 0);

    pub fn next() {
        if this.index >= this.array.len() {
            return nil;
        }

        let value = this.array[this.index];

        this.index += 1;

        return some(value);
    }
}