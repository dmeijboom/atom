module std.map;

import std.core.{
    rt_raise,
    some,
    Tuple,
    println,
    Enum,
    Filter,
    String,
    GetIterator
};
import std.math.mul64;
import std.encoding.binary.{parseInt, parseUint};

pub class MapIter {
    let map;
    let mut index;

    pub static fn new(map) -> MapIter(map: map, index: 0);

    pub fn next() {
        let index = this.index;
        let item = this.map.getByIndex(this.index);

        if item.isNone() {
            return nil;
        }

        this.index += 1;

        let entry = item!;

        return some((entry.key, entry.value));
    }
}

fn encodeKey(key) {
    # Make sure each basic type is different even though the string values are the same
    let mut bytes = [(Byte)(typeof key).typeId()];

    bytes.append(key.toString().bytes());

    return bytes;
}

fn wyr8(bytes) {
    return (Uint64)parseInt(bytes);
}

fn wyr4(bytes) {
    return (Uint64)parseUint(bytes);
}

fn wyr3(bytes, index) {
    return (Uint64)bytes[0] << 16
        | (Uint64)bytes[index >> 1] << 8
        | (Uint64)bytes[index - 1];
}

fn wymix(a, b) {
    let (ra, rb) = mul64(a, b);

    return ra ^ rb;
}

pub fn wyseed(bytes, mut seed) {
    let wyp0 = 0xa0761d6478bd642f;
    let wyp1 = 0xe7037ed1a0b428db;
    let wyp2 = 0x8ebc6af09c88c6e3;
    let wyp3 = 0x589965cc75374cc3;

    seed = (Uint64)seed ^ wyp0;

    if bytes.len() <= 16 {
        if bytes.len() <= 8 {
            if bytes.len() >= 4 {
                let a = wyr4(bytes[0..4]);
                let b = wyr4(bytes[bytes.len()-4..bytes.len()]);

                return wymix(a ^ wyp1, b ^ seed);
            } else if !bytes.isEmpty() {
                let a = wyr3(bytes, bytes.len());
                let b = 0;

                return wymix(a ^ wyp1, b ^ seed);
            } else {
                let a = 0;
                let b = 0;

                return wymix(a ^ wyp1, b ^ seed);
            }
        } else {
            let a = wyr8(bytes[0..8]);
            let b = wyr8(bytes[bytes.len()-8..bytes.len()]);

            return wymix(a ^ wyp1, b ^ seed);
        }
    } else {
        let mut i = bytes.len();
        let mut pos = 0;

        if bytes.len() > 48 {
            let mut seed1 = seed;
            let mut seed2 = seed;

            for {
                seed = wymix(
                    wyr8(bytes[pos..pos+8]) ^ wyp1,
                    wyr8(bytes[pos+8..pos+8+8]) ^ seed
                );

                seed1 = wymix(
                    wyr8(bytes[pos+16..pos+16+8]) ^ wyp2,
                    wyr8(bytes[pos+24..pos+24+8]) ^ seed1
                );

                seed2 = wymix(
                    wyr8(bytes[pos+32..pos+32+8]) ^ wyp3,
                    wyr8(bytes[pos+40..pos+40+8]) ^ seed2
                );

                pos += 48;
                i -= 48;

                if i <= 48 {
                    break;
                }
            }

            seed = seed ^ seed1 ^ seed2;
        }

        if i > 16 {
            seed = wymix(
                wyr8(bytes[pos..pos+8]) ^ wyp1,
                wyr8(bytes[pos+8..pos+8+8]) ^ seed
            );

            pos += 16;
            i -= 16;
        }

        let mut offset = pos + i - 17;
        let a = wyr8(bytes[offset..offset+8]);

        offset = pos + i - 9;
        let b = wyr8(bytes[offset..offset+8]);

        return wymix(a ^ wyp1, b ^ seed);
    }
}

pub fn hash(bytes, seed) {
    let wyp1 = 0xe7037ed1a0b428db;
    let newSeed = wyseed(bytes, seed);

    return wymix(wyp1 ^ bytes.len(), newSeed);
}

class Entry {
    let hash;
    let key;
    let value;

    pub static fn new(hash, key, value) -> Entry(hash: hash, key: key, value: value);
}

class Bucket {
    let mut entry;
    let mut next;

    pub static fn new() -> Bucket(entry: nil, next: nil);
    pub static fn withEntry(entry) -> Bucket(entry: some(entry), next: nil);
}

pub class Map extends GetIterator {
    let buckets;
    let mut size;

    pub fn len() -> this.size;
    pub fn iter() -> MapIter.new(this);

    pub static fn from(pairs) {
        let map = Map(buckets: [], size: 0);

        for (key, value) in pairs {
            map.set(key, value);
        }

        return map;
    }

    fn grow() {
        if this.size == 0 {
            for 0..5 {
                this.buckets.push(Bucket.new());
            }
        } else {
            raise "not supported";
        }
    }

    fn getByIndex(index) {
        let mut i = index;

        for bucket in this.buckets {
            if i < 0 {
                break;
            }

            let mut current = bucket;

            for {
                if current.entry.isSome() {
                    if i == 0 {
                        return current.entry;
                    }

                    i -= 1;
                }

                if current.next.isNone() {
                    break;
                }

                current = current.next!;
            }
        }

        return nil;
    }

    pub fn set(key, value) {
        if this.buckets.len() == 0 {
            this.grow();
        }

        let hash = hash(encodeKey(key), 0);
        let index = hash % this.buckets.len();
        let bucket = this.buckets.nth(index)!;
        let entry = Entry.new(hash, key, value);

        if bucket.entry.isNone() {
            this.size += 1;

            bucket.entry = some(entry);
        } else {
            let mut tail = bucket;

            for {
                if tail.entry!.hash == hash {
                    tail.entry = some(entry);

                    return nil;
                }

                if tail.next.isNone() {
                    break;
                }

                tail = tail.next!;
            }

            tail.next = some(Bucket.withEntry(entry));
            this.size += 1;
        }
    }

    pub fn get(key) {
        if this.buckets.len() == 0 {
            return nil;
        }

        let hash = hash(encodeKey(key), 0);
        let index = hash % this.buckets.len();
        let bucket = this.buckets.nth(index)!;

        if bucket.entry.isSome() {
            let mut current = bucket;

            for {
                if current.entry!.hash == hash {
                    return some(current.entry!.value);
                }

                if current.next.isNone() {
                    break;
                }

                current = current.next!;
            }
        }

        return nil;
    }
}
