module std.core;

pub extern fn println(values);
pub extern fn some(value);

pub interface Iterable {
    fn iter();
}

pub class Option {
    pub extern fn isSome();
    pub extern fn isNone();

    pub fn unwrapOr(alt) {
        if this.isSome() {
            return this!;
        }

        return alt;
    }
}

pub class String {
    pub let length;

    pub extern fn upper();
    pub extern fn lower();
    pub extern fn split(pattern);
    pub extern fn splitn(pattern);
    pub extern fn startsWith(pattern);
    pub extern fn endsWith(pattern);
    pub extern fn contains(pattern);
    pub extern fn count(pattern);
    pub extern fn find(pattern);
    pub extern fn replace(pattern, replacement);
    pub extern fn append(other);
    pub extern fn chars();
    pub extern fn repeat(n);
    pub extern fn trim();
    pub extern fn len();

    pub fn containsAny(values) {
        let chars = this.chars();

        for c2 in values.chars() {
            for c1 in chars {
                if c1 == c2 {
                    return true;
                }
            }
        }

        return false;
    }
}

pub class Int {
    pub fn toString() {
        return f"{this}";
    }
}

pub class Float {
    pub extern fn floor();

    pub fn toString() {
        return f"{this}";
    }
}

pub class Char {
    pub fn toString() {
        return f"{this}";
    }
}

pub class Byte {
    pub fn toString() {
        return f"{this}";
    }
}

pub class Bool {
    pub fn toString() {
        return f"{this}";
    }
}

pub class RangeIter {
    let start;
    let end;
    let step;
    let mut index;

    pub fn next() {
        let index = this.start + this.index;

        if index >= this.end {
            return nil;
        }

        let value = some(index);

        this.index += this.step;

        return value;
    }
}

pub class RangeStep {
    let range;
    let step;

    pub fn iter() {
        return RangeIter(start: this.range.start(), end: this.range.end(), step: this.step, index: 0);
    }

    pub fn collect() {
        let mut output = [];

        for i in this {
            output.push(i);
        }

        return output;
    }
}

pub class Range {
    pub extern fn start();
    pub extern fn end();

    pub fn iter() {
        return RangeIter(start: this.start(), end: this.end(), step: 1, index: 0);
    }

    pub fn step(n) {
        return RangeStep(range: this, step: n);
    }

    pub fn collect() {
        let mut output = [];

        for i in this {
            output.push(i);
        }

        return output;
    }
}

pub class ArrayIter {
    let array;
    let mut index;

    pub fn next() {
        if this.index >= this.array.len() {
            return nil;
        }

        let value = this.array.nth(this.index);

        this.index += 1;

        return value;
    }
}

pub class Array {
    pub extern fn push(value);
    pub extern fn pop();
    pub extern fn len();
    pub extern fn clear();

    pub fn nth(index) {
        if index < 0 || this.len() <= index {
            return nil;
        }

        unsafe {
            return some(this[index]);
        }
    }

    pub fn first() {
        return this.nth(0);
    }

    pub fn last() {
        return this.nth(this.len()-1);
    }

    pub fn iter() {
        return ArrayIter(array: this, index: 0);
    }

    pub fn append(other) {
        for {
            let item = other.remove(0);

            if !item.isSome() {
                break;
            }

            this.push(item!);
        }
    }

    pub fn slice(range) {
        let mut output = [];

        for item in range {
            unsafe {
                output.push(this[item]);
            }
        }

        return output;
    }

    pub fn contains(value) {
        for item in this {
            if item == value {
                return true;
            }
        }

        return false;
    }

    pub fn join(separator) {
        let mut output = "";
        let length = this.len();

        for i in 0..length {
            unsafe {
                let value = this[i];

                if value is String {
                    output.append(value);
                } else {
                    output.append(f"{value}");
                }

                if i < length - 1 {
                    output.append(separator);
                }
            }
        }

        return output;
    }
}

pub class KeyValue {
    pub let key;
    pub let value;
}

pub class MapIter {
    let data;
    let keys;
    let mut index;

    pub fn next() {
        if this.index >= this.keys.len() {
            return nil;
        }

        unsafe {
            let key = this.keys[this.index];
            let key_value = KeyValue(key: key, value: this.data[key]);

            this.index += 1;

            return some(key_value);
        }
    }
}

pub class Map {
    pub extern fn keys();
    pub extern fn len();
    pub extern fn remove(key);
    pub extern fn clear();

    pub fn iter() {
        return MapIter(data: this, keys: this.keys(), index: 0);
    }

    pub fn get(key) {
        if !this.keys().contains(key) {
            return nil;
        }

        unsafe {
            return some(this[key]);
        }
    }

    pub fn set(key, value) {
        unsafe {
            this[key] = value;
        }
    }
}
