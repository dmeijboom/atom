class Node {
    let left;
    let value;
    let right;
}

fn make_tree(value, depth) {
    if depth == 0 {
        return &Node(left: nil, value: value, right: nil);
    }

    let value2 = value + value;

    return &Node(
        left: some(make_tree((value + value) - 1, depth - 1)),
        value: value,
        right: some(make_tree(value + value, depth - 1)),
    );
}

fn check_tree(node) {
    if !node.left.isSome() {
        return node.value;
    }

    return node.value + check_tree(node.left.value()) - check_tree(node.right.value());
}

fn main() {
    let min_depth = 4;
    let max_depth = 12;
    let stretch_depth = max_depth + 1;

    println(f"stretch tree of depth {stretch_depth} check: {check_tree(make_tree(0, stretch_depth))}");

    let long_lived_tree = make_tree(0, max_depth);
    let mut iterations = 2 ** max_depth;

    for (min_depth..stretch_depth).step(2) {
        let depth = .;
        let mut check = 0;

        for 1..(iterations + 1) {
            check = check + check_tree(make_tree(., depth)) + check_tree(make_tree(0 - ., depth));
        }

        println(f"{iterations * 2} trees of depth {depth} check: {check}");

        iterations = (Int)(((Float)iterations / 4).floor());
    }

    println(f"long lived tree of depth {max_depth} check: {check_tree(long_lived_tree)}");
}
