class Node {
    let left;
    let value;
    let right;
}

fn makeTree(value, depth) {
    if depth == 0 {
        return Node(left: nil, value: value, right: nil);
    }

    return Node(
        left: some(makeTree((value + value) - 1, depth - 1)),
        value: value,
        right: some(makeTree(value + value, depth - 1)),
    );
}

fn checkTree(node) {
    if !node.left.isSome() {
        return node.value;
    }

    return node.value + checkTree(node.left!) - checkTree(node.right!);
}

fn main() {
    let minDepth = 4;
    let maxDepth = 12;
    let stretchDepth = maxDepth + 1;

    println(f"stretch tree of depth {stretchDepth} check: {checkTree(makeTree(0, stretchDepth))}");

    let long_livedTree = makeTree(0, maxDepth);
    let mut iterations = 2.0 ** maxDepth;

    for depth in (minDepth..stretchDepth).step(2) {
        let mut check = 0;

        for i in 1..(iterations + 1) {
            check += checkTree(makeTree(i, depth)) + checkTree(makeTree(0 - i, depth));
        }

        println(f"{iterations * 2} trees of depth {depth} check: {check}");

        iterations = ((Float)iterations / 4).floor();
    }

    println(f"long lived tree of depth {maxDepth} check: {checkTree(long_livedTree)}");
}
