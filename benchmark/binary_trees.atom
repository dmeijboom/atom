fn makeTree(value, depth) {
    if depth == 0 {
        return (nil, value, nil);
    }

    return (makeTree((value + value) - 1, depth - 1), value, makeTree(value + value, depth - 1));
}

fn checkTree(node) {
    if node[0] == nil {
        return node[1];
    }

    return node[1] + checkTree(node[0]) - checkTree(node[2]);
}

fn main() {
    let minDepth = 4;
    let maxDepth = 12;
    let stretchDepth = maxDepth + 1;

    println(f"stretch tree of depth {stretchDepth} check: {checkTree(makeTree(0, stretchDepth))}");

    let long_livedTree = makeTree(0, maxDepth);
    let mut iterations = 2.0 ** maxDepth;

    for depth in (minDepth..stretchDepth).step(2) {
        let mut check = 0;

        for i in 1..(iterations + 1) {
            check += checkTree(makeTree(i, depth)) + checkTree(makeTree(0 - i, depth));
        }

        println(f"{iterations * 2} trees of depth {depth} check: {check}");

        iterations = ((Float)iterations / 4).floor();
    }

    println(f"long lived tree of depth {maxDepth} check: {checkTree(long_livedTree)}");
}
